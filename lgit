#!/bin/bash -e

#############################
## Private implementation ###
#############################
__lgitInit()
{
	if [[ -d ./.git ]]; then
		echo -e "\e[01;31mlgit: can't add a git repo inside another git repo\e[00m"
		exit -1
	fi
	if [[ -d "./$1" ]]; then
		echo -e "\e[01;31mlgit: folder '$1' already exists\e[00m"
		exit -1
	fi
	git ls-remote "$2" &> /dev/null
	if [ "$?" -ne 0 ]; then
		echo -e "\e[01;31mlgit: unable to read from '$2'\e[00m"
		exit -1;
	fi

	mkdir $1
	cd $1
	git init
	git remote add origin $2
	git fetch
	git reset --hard origin/master
	cd ..
}

__lgitInitAndPush()
{
	if [[ -d ./.git ]]; then
		echo -e "\e[01;31mlgit: already a repo git\e[00m"
		exit -1
	fi
	git ls-remote "$1" &> /dev/null
	if [ "$?" -ne 0 ]; then
		echo -e "\e[01;31mlgit: unable to read from '$1'\e[00m"
		exit -1;
	fi

	echo "git init"
	git init
	echo "git remote add origin $1";
	git remote add origin "$1"
	echo "git fetch"
	git fetch
	echo "git checkout master"
	git checkout master
	echo "git add ."
	git add .
	echo "git commit -m \"LGit initialize repo from local folder\""
	git commit -m "LGit initialize repo from local folder"
	git push -u origin master
}

__lgitMergeAndPushToMaster()
{
	git update-index -q --refresh
	if git diff-index --quiet HEAD --; then
		git fetch
		local current_branch=`git rev-parse --symbolic-full-name --abbrev-ref HEAD`
		local commits_behind=`git rev-list --left-right $current_branch...origin/master | grep -c "^>"`
		if [ $commits_behind = 0 ]; then
			git checkout master
			git reset --hard origin/master
			git merge $current_branch
			git push origin master
			git checkout $current_branch
		else
			echo -e "\e[01;31mlgit: $commits_behind commits behind, please rebase your branch\e[00m"
		fi
	else
		echo -e "\e[01;31mlgit: ncommited changes, please commit\e[00m"
	fi
}

__lgitMoveToBranch()
{
	git show-ref --verify --quiet refs/heads/"$1" &>-
	if [ "$?" -ne 0 ]; then
		echo -e "\e[01;31mlgit: branch '$1' doesn't exist\e[00m"
		exit -1;
	fi
	local current_branch=`git rev-parse --symbolic-full-name --abbrev-ref HEAD`
	git checkout "$1"
	git reset --hard $current_branch	
}

__lgitPush()
{
	git push origin `git rev-parse --symbolic-full-name --abbrev-ref HEAD`
}

__lgitPushForce()
{
	local current_branch=`git rev-parse --symbolic-full-name --abbrev-ref HEAD`
	read -p "Do you want to force push the branch $current_branch ? (y/n)"
	[ "$REPLY" == "y" ] || git push -f origin $current_branch
}

__lgitRebase()
{
	local current_branch=`git rev-parse --symbolic-full-name --abbrev-ref HEAD`
	git fetch
}

############################
## call management #########
############################
if [[ "$1" == "init" ]]; then
	__lgitInit $2 $3
elif [[ "$1" == "init-push" ]]; then
	__lgitInitAndPush $2
elif [[ -d ./.git ]]; then
	if [[ "$1" == "master-push" ]]; then
		__lgitMergeAndPushToMaster
	elif [[ "$1" == "move" ]]; then
		__lgitMoveToBranch $2
	elif [[ "$1" == "push" ]]; then
		__lgitPush
	elif [[ "$1" == "push-force" ]]; then
		__lgitPushForce
	elif [[ "$1" == "rebase" ]]; then
		__lgitRebase
	else
		echo -e "\e[01;31mlgit: '$1' is not a lgit command.\e[00m"
	fi
else
	echo -e "\e[01;31mlgit: must be used in a git repository\e[00m"
fi

